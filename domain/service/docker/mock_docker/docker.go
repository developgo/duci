// Code generated by MockGen. DO NOT EDIT.
// Source: domain/service/docker/docker.go

// Package mock_docker is a generated GoMock package.
package mock_docker

import (
	"context"
	docker0 "github.com/duck8823/duci/domain/model/docker"
	"github.com/duck8823/duci/domain/model/log"
	docker1 "github.com/duck8823/duci/infrastructure/docker"
	"github.com/golang/mock/gomock"
	"io"
	"reflect"
)

// MockDocker is a mock of Docker interface
type MockDocker struct {
	ctrl     *gomock.Controller
	recorder *MockDockerMockRecorder
}

// MockDockerMockRecorder is the mock recorder for MockDocker
type MockDockerMockRecorder struct {
	mock *MockDocker
}

// NewMockDocker creates a new mock instance
func NewMockDocker(ctrl *gomock.Controller) *MockDocker {
	mock := &MockDocker{ctrl: ctrl}
	mock.recorder = &MockDockerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockDocker) EXPECT() *MockDockerMockRecorder {
	return m.recorder
}

// Build mocks base method
func (m *MockDocker) Build(ctx context.Context, file io.Reader, tag docker0.Tag, dockerfile docker0.Dockerfile) (log.Log, error) {
	ret := m.ctrl.Call(m, "Build", ctx, file, tag, dockerfile)
	ret0, _ := ret[0].(log.Log)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Build indicates an expected call of Build
func (mr *MockDockerMockRecorder) Build(ctx, file, tag, dockerfile interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Build", reflect.TypeOf((*MockDocker)(nil).Build), ctx, file, tag, dockerfile)
}

// Run mocks base method
func (m *MockDocker) Run(ctx context.Context, opts docker1.RuntimeOptions, tag docker0.Tag, cmd docker0.Command) (docker0.ContainerID, log.Log, error) {
	ret := m.ctrl.Call(m, "Run", ctx, opts, tag, cmd)
	ret0, _ := ret[0].(docker0.ContainerID)
	ret1, _ := ret[1].(log.Log)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Run indicates an expected call of Run
func (mr *MockDockerMockRecorder) Run(ctx, opts, tag, cmd interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockDocker)(nil).Run), ctx, opts, tag, cmd)
}

// Rm mocks base method
func (m *MockDocker) Rm(ctx context.Context, containerID docker0.ContainerID) error {
	ret := m.ctrl.Call(m, "Rm", ctx, containerID)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rm indicates an expected call of Rm
func (mr *MockDockerMockRecorder) Rm(ctx, containerID interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rm", reflect.TypeOf((*MockDocker)(nil).Rm), ctx, containerID)
}

// Rmi mocks base method
func (m *MockDocker) Rmi(ctx context.Context, tag docker0.Tag) error {
	ret := m.ctrl.Call(m, "Rmi", ctx, tag)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rmi indicates an expected call of Rmi
func (mr *MockDockerMockRecorder) Rmi(ctx, tag interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rmi", reflect.TypeOf((*MockDocker)(nil).Rmi), ctx, tag)
}

// ExitCode mocks base method
func (m *MockDocker) ExitCode(ctx context.Context, containerID docker0.ContainerID) (docker0.ExitCode, error) {
	ret := m.ctrl.Call(m, "ExitCode", ctx, containerID)
	ret0, _ := ret[0].(docker0.ExitCode)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExitCode indicates an expected call of ExitCode
func (mr *MockDockerMockRecorder) ExitCode(ctx, containerID interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExitCode", reflect.TypeOf((*MockDocker)(nil).ExitCode), ctx, containerID)
}

// Status mocks base method
func (m *MockDocker) Status() error {
	ret := m.ctrl.Call(m, "Status")
	ret0, _ := ret[0].(error)
	return ret0
}

// Status indicates an expected call of Status
func (mr *MockDockerMockRecorder) Status() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockDocker)(nil).Status))
}
