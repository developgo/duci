// Code generated by MockGen. DO NOT EDIT.
// Source: domain/model/docker/docker.go

// Package mock_docker is a generated GoMock package.
package mock_docker

import (
	context "context"
	docker "github.com/duck8823/duci/domain/model/docker"
	job "github.com/duck8823/duci/domain/model/job"
	gomock "github.com/golang/mock/gomock"
	io "io"
	reflect "reflect"
)

// MockDocker is a mock of Docker interface
type MockDocker struct {
	ctrl     *gomock.Controller
	recorder *MockDockerMockRecorder
}

// MockDockerMockRecorder is the mock recorder for MockDocker
type MockDockerMockRecorder struct {
	mock *MockDocker
}

// NewMockDocker creates a new mock instance
func NewMockDocker(ctrl *gomock.Controller) *MockDocker {
	mock := &MockDocker{ctrl: ctrl}
	mock.recorder = &MockDockerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockDocker) EXPECT() *MockDockerMockRecorder {
	return m.recorder
}

// Build mocks base method
func (m *MockDocker) Build(ctx context.Context, file io.Reader, tag docker.Tag, dockerfile docker.Dockerfile) (job.Log, error) {
	ret := m.ctrl.Call(m, "Build", ctx, file, tag, dockerfile)
	ret0, _ := ret[0].(job.Log)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Build indicates an expected call of Build
func (mr *MockDockerMockRecorder) Build(ctx, file, tag, dockerfile interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Build", reflect.TypeOf((*MockDocker)(nil).Build), ctx, file, tag, dockerfile)
}

// Run mocks base method
func (m *MockDocker) Run(ctx context.Context, opts docker.RuntimeOptions, tag docker.Tag, cmd docker.Command) (docker.ContainerID, job.Log, error) {
	ret := m.ctrl.Call(m, "Run", ctx, opts, tag, cmd)
	ret0, _ := ret[0].(docker.ContainerID)
	ret1, _ := ret[1].(job.Log)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Run indicates an expected call of Run
func (mr *MockDockerMockRecorder) Run(ctx, opts, tag, cmd interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockDocker)(nil).Run), ctx, opts, tag, cmd)
}

// RemoveContainer mocks base method
func (m *MockDocker) RemoveContainer(ctx context.Context, containerID docker.ContainerID) error {
	ret := m.ctrl.Call(m, "RemoveContainer", ctx, containerID)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveContainer indicates an expected call of RemoveContainer
func (mr *MockDockerMockRecorder) RemoveContainer(ctx, containerID interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveContainer", reflect.TypeOf((*MockDocker)(nil).RemoveContainer), ctx, containerID)
}

// RemoveImage mocks base method
func (m *MockDocker) RemoveImage(ctx context.Context, tag docker.Tag) error {
	ret := m.ctrl.Call(m, "RemoveImage", ctx, tag)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveImage indicates an expected call of RemoveImage
func (mr *MockDockerMockRecorder) RemoveImage(ctx, tag interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveImage", reflect.TypeOf((*MockDocker)(nil).RemoveImage), ctx, tag)
}

// ExitCode mocks base method
func (m *MockDocker) ExitCode(ctx context.Context, containerID docker.ContainerID) (docker.ExitCode, error) {
	ret := m.ctrl.Call(m, "ExitCode", ctx, containerID)
	ret0, _ := ret[0].(docker.ExitCode)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExitCode indicates an expected call of ExitCode
func (mr *MockDockerMockRecorder) ExitCode(ctx, containerID interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExitCode", reflect.TypeOf((*MockDocker)(nil).ExitCode), ctx, containerID)
}

// Status mocks base method
func (m *MockDocker) Status() error {
	ret := m.ctrl.Call(m, "Status")
	ret0, _ := ret[0].(error)
	return ret0
}

// Status indicates an expected call of Status
func (mr *MockDockerMockRecorder) Status() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockDocker)(nil).Status))
}
